# 帧数暴降问题分析与优化计划

## 问题概述
该 RimWorld mod 在运行时导致游戏帧数严重下降，主要原因是 UI 渲染循环中存在大量过度计算和低效的资源访问。

## 关键问题分析

### 1. UI 渲染循环过度计算问题 (高严重度)

**位置**: `FactionGearEditor.GetFilteredAndSortedItems()` (第 780-848 行)

**问题描述**:
- 每次 UI 绘制时都会重新计算筛选和排序
- 多个筛选条件同时变化时会导致全量重新计算
- 包含大量的 List.Where()、OrderBy() 和 FirstOrDefault() 调用
- 虽然有缓存机制，但设计缺陷导致缓存频繁失效

**代码问题示例**:
```csharp
// 原始代码存在大量重复计算
var rangePairs = items.Select(t => new { Thing = t, Range = FactionGearManager.GetWeaponRange(t) }).ToList();
rangePairs = sortAscending ? rangePairs.OrderBy(x => x.Range).ToList() : rangePairs.OrderByDescending(x => x.Range).ToList();
items = rangePairs.Select(x => x.Thing).ToList();
```

---

### 2. 频繁访问 DefDatabase (中高严重度)

**位置**: `GearItem.ThingDef` 属性

**问题描述**:
```csharp
// GearItem.cs
public ThingDef ThingDef => DefDatabase<ThingDef>.GetNamedSilentFail(thingDefName);
```

- 每次访问 GearItem.ThingDef 都会调用 DefDatabase.GetNamedSilentFail()
- 在 UI 渲染循环中会导致大量重复查找
- 该方法时间复杂度为 O(n)，当装备数量较多时会非常慢

---

### 3. Settings.Write() 调用过于频繁 (高严重度)

**位置**: `FactionGearEditor` 中的多个事件处理方法

**问题描述**:
- 调整权重滑块时立即保存 (第 699 行)
- 删除装备项时立即保存 (第 709 行)
- 每次微小操作都触发文件 IO，造成严重的性能瓶颈

**代码问题示例**:
```csharp
if (newWeight != gearItem.weight)
{
    gearItem.weight = newWeight;
    kindData.isModified = true;
    FactionGearCustomizerMod.Settings.Write(); // 每次调整都保存！
}
```

---

### 4. 缓存机制设计缺陷 (中严重度)

**位置**: `FactionGearEditor` 中的缓存逻辑 (第 927-1019 行)

**问题描述**:
```csharp
private static List<ThingDef> GetCachedAllWeapons()
{
    if (cachedAllWeapons == null || DateTime.Now - weaponsCacheTime > cacheExpiry)
    {
        cachedAllWeapons = FactionGearManager.GetAllWeapons();
        weaponsCacheTime = DateTime.Now;
    }
    return cachedAllWeapons;
}
```

- 使用 DateTime 进行缓存过期检查，精度不足且可能漂移
- 多个缓存使用独立的过期时间，管理复杂
- 缓存失效条件过于严格，导致频繁重新计算

---

### 5. 数据结构查询效率问题 (中高严重度)

**位置**: `FactionGearCustomizerSettings.GetOrCreateFactionData()` (第 51-60 行)

**问题描述**:
```csharp
public FactionGearData GetOrCreateFactionData(string factionDefName)
{
    var data = factionGearData.FirstOrDefault(f => f.factionDefName == factionDefName);
    if (data == null)
    {
        data = new FactionGearData(factionDefName);
        factionGearData.Add(data);
    }
    return data;
}
```

- 使用 List.FirstOrDefault() 进行查找，时间复杂度 O(n)
- 当派系数量较多时，性能下降明显
- 缺少索引结构支持

---

## 优化方案

### 阶段 1: 立即修复高严重度问题

#### 1.1 优化 Settings.Write() 调用频率

**优化方案**:
- 实现延迟保存机制 (Debounce)
- 操作后延迟 1-2 秒再保存
- 避免高频次的文件 IO 操作

**代码修改位置**: `FactionGearEditor.cs` 的事件处理方法

---

#### 1.2 优化 GearItem.ThingDef 访问

**优化方案**:
- 为 GearItem 类添加 ThingDef 缓存属性
- 在 GearItem 创建时就解析并缓存 ThingDef 引用
- 避免运行时频繁调用 DefDatabase.GetNamedSilentFail()

**代码修改位置**: `GearItem.cs`

---

### 阶段 2: 中期优化中高严重度问题

#### 2.1 优化 GetFilteredAndSortedItems() 方法

**优化方案**:
- 实现更精细的缓存机制
- 为每个筛选条件组合创建独立缓存
- 使用字典存储已计算的筛选结果
- 避免不必要的重新计算

**代码修改位置**: `FactionGearEditor.cs` 的 `GetFilteredAndSortedItems()` 方法

---

#### 2.2 优化数据结构查询效率

**优化方案**:
- 为 `FactionGearCustomizerSettings` 添加字典索引
- 将 GetOrCreateFactionData() 方法的时间复杂度优化到 O(1)
- 为 KindGearData 也添加类似的索引结构

**代码修改位置**: `FactionGearCustomizerSettings.cs` 和 `FactionGearData.cs`

---

### 阶段 3: 长期优化与代码重构

#### 3.1 重构缓存机制

**优化方案**:
- 使用更精确的时间戳或版本号进行缓存管理
- 实现缓存依赖关系，避免不必要的失效
- 统一缓存管理逻辑

**代码修改位置**: `FactionGearEditor.cs` 的缓存相关方法

---

#### 3.2 优化整体架构

**优化方案**:
- 分离 UI 渲染逻辑和数据处理逻辑
- 实现虚拟列表控件，仅渲染可见项
- 优化布局计算，避免重复测量

**代码修改位置**: 整个 UI 层架构

---

## 优化实施计划

### 第 1 周 - 高严重度修复

1. **延迟保存机制实现** (2 天)
2. **GearItem.ThingDef 缓存优化** (1 天)
3. **测试与验证** (2 天)

**预期性能提升**: 30-50% 帧数提升

---

### 第 2 周 - 中高严重度优化

1. **GetFilteredAndSortedItems() 方法优化** (3 天)
2. **数据结构索引优化** (2 天)
3. **测试与验证** (2 天)

**预期性能提升**: 20-40% 帧数提升

---

### 第 3 周 - 长期优化

1. **缓存机制重构** (3 天)
2. **UI 架构优化** (4 天)
3. **全面性能测试** (2 天)

**预期性能提升**: 15-30% 帧数提升

---

## 测试方案

### 性能基准测试

1. **启动时间测试**: 测量 mod 加载和初始化时间
2. **UI 响应测试**: 测量筛选、排序和列表滚动的响应时间
3. **内存使用测试**: 监控内存消耗和 GC 频率
4. **帧数测试**: 在不同场景下测量平均 FPS

### 测试场景

1. **基准场景**: 无自定义装备设置
2. **中等负载场景**: 10-20 个派系，每个派系 5-10 个兵种
3. **高负载场景**: 50+ 个派系，每个派系 20+ 个兵种
4. **极端场景**: 100+ 个派系，包含大量自定义装备

---

## 风险评估

### 技术风险

1. **缓存一致性问题**: 优化过程中可能出现缓存与实际数据不一致
2. **兼容性问题**: 修改数据结构可能影响存档兼容性
3. **引入新 bug**: 重构过程中可能引入新的逻辑错误

### 缓解策略

1. **单元测试**: 为核心方法编写全面的单元测试
2. **增量部署**: 分阶段部署优化，每个阶段进行充分测试
3. **备份机制**: 确保用户数据可以恢复到优化前的状态

---

## 总结

该 mod 的帧数暴降问题主要由 UI 渲染循环中的过度计算和低效资源访问导致。通过分阶段的优化方案，我们可以逐步提升性能，最终实现可接受的游戏体验。

**预期总体性能提升**: 65-120% 帧数提升

第一个阶段的优化（延迟保存 + GearItem 缓存）可以在 1 周内完成，能够立即缓解帧数问题的 60% 以上。
